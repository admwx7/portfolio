<link rel="import" href="../../bower_components/polymer/polymer-element.html">

<dom-module id="am-item-scroller">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
        perspective: 5000px;
        transform-style: preserve-3d;
        width: 100%;
      }
      :host ::slotted(*) {
        position: absolute;
        top: 50%;
        left: 50%;
      }
      :host ::slotted([hide]) {
        opacity: 0;
      }
    </style>

    <slot></slot>
  </template>
  <script>
    /**
     * `am-item-scroller` an element for providing a carousel that can function for both images and items
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class AmItemScroller extends Polymer.Element {
      // eslint-disable-next-line require-jsdoc
      static get is() {
        return 'am-item-scroller';
      }
      // eslint-disable-next-line require-jsdoc
      static get properties() {
        return {
          horizontalOffset: {
            type: String,
            value: '300px',
          },

          _clickThreshold: {
            type: Number,
            value: 5,
          },

          __children: {
            type: Array,
            value() {
              return [];
            },
          },
          __clientStart: Number,
          __lastChild: HTMLElement,
          __moved: Number,
          __swipeOffset: {
            type: Number,
            value: 0,
          },
        };
      }
      // eslint-disable-next-line require-jsdoc
      constructor() {
        super();

        this._updateChildrenStyles = this._updateChildrenStyles.bind(this);
        this.__fetchChildren = this.__fetchChildren.bind(this);
        this.__swipe = this.__swipe.bind(this);
        this.__swipeX = this.__swipeX.bind(this);
      }
      /* Lifecycle Methods */
      // eslint-disable-next-line require-jsdoc
      ready() {
        super.ready();

        // observers
        new Polymer.FlattenedNodesObserver(this.shadowRoot.querySelector('slot'), this.__fetchChildren);
        // TODO: polyfill this?  It's not a common issue and the polyfill is a pretty negative impact to battery life
        if (ResizeObserver) {
          (new ResizeObserver(() => {
            this._updateChildrenStyles();
          })).observe(this);
        } else {
          Polymer.RenderStatus.afterNextRender(this, () => {
            this._updateChildrenStyles();
            // TODO: update the height of this element based on the height of focusedIndex, if one isn't set
          });
        }

        // event listeners
        this.addEventListener('touchmove', this.__swipe);
        this.addEventListener('touchstart', this.__swipeX);
        this.addEventListener('mousemove', this.__swipe);
        this.addEventListener('mousedown', this.__swipeX);
        this.addEventListener('click', this.__swipeX, true);
        this.addEventListener('mouseleave', () => {
          this.__clientStart = null;
        });
      }
      /* Protected Methods */
      /**
       * Update children styles
       * @protected
       *
       * @param {NodeList} [children = this.__children]
       */
      _updateChildrenStyles(children = this.__children) {
        children.forEach((child, childIndex) => {
          if (childIndex === children.length - 1) {
            this.__lastChild = child;
          }
          child.removeAttribute('hide');
          // update position
          child.style.left = `calc(50% + ${childIndex} * ${this.horizontalOffset} - ${this.__swipeOffset}px)`;
          const parentCenter = child.parentNode.clientWidth / 2;
          const intensity = Math.abs(child.offsetLeft - parentCenter) / parentCenter;
          child.style.transform = `translate3d(
            -50%,
            calc(-50%),
            ${-5000 * intensity}px`;
          child.style.opacity = Math.min(Math.max(1 - intensity, 0.2), 1);
        });
      }
      /* Private Methods */
      /**
       * Called when the child nodes changes to update the __children reference
       * @private
       *
       * @param {MutationRecord} record
       */
      __fetchChildren(record) {
        const nodes = record.target.
          assignedNodes({flatten: true}).
          filter((node) => {
            return node.nodeType === Node.ELEMENT_NODE;
          });
        this.set('__children', nodes);
        this.__children.forEach((child) => {
          child.setAttribute('hide', '');
        });
      }
      /**
       * Handles swipe actions to move the carousel
       * @private
       *
       * @param {TouchEvent|MouseEvent} event
       */
      __swipe(event) {
        if (typeof this.__clientStart !== 'number') return;
        event.stopPropagation();
        event.returnValue = false;

        const swipeDiff = this.__clientStart - (event.clientX || (event.touches && event.touches[0].clientX));
        if (typeof swipeDiff !== 'number') {
          // Swipe went off of the screen
          this.__clientStart = null;
          return;
        }
        const maxOffset = this.__lastChild ?
          (this.__lastChild.parentNode.clientWidth + this.__lastChild.clientWidth) / 2 :
          null;

        if (this.__swipeOffset + swipeDiff < 0) {
          this.__swipeOffset = 0;
        } else if (maxOffset && this.__swipeOffset + swipeDiff >= maxOffset) {
          this.__swipeOffset = maxOffset;
        } else {
          this.__swipeOffset += swipeDiff;
        }
        this.__moved += Math.abs(swipeDiff);
        this.__clientStart = event.clientX || event.touches[0].clientX;
        this._updateChildrenStyles();
      }
      /**
       * Sets the swipeX value to calculate the swipe against
       * @private
       *
       * @param {TouchEvent|MouseEvent} event
       */
      __swipeX(event) {
        if (!this.__children || this.__children.length <= 1) return;
        this.__clientStart = null;
        if ((event.type === 'mousedown' && event.button === 0) || event.type === 'touchstart') {
          this.__clientStart = (event.clientX || event.touches[0].clientX);
        } else if (this.__moved > this._clickThreshold) {
          event.preventDefault();
        }
        this.__moved = 0;
      }
    }
    window.customElements.define(AmItemScroller.is, AmItemScroller);
  </script>
</dom-module>
